#
# @lc app=leetcode.cn id=1263 lang=python3
#
# [1263] 推箱子
#
# 「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。

# 游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。

# 现在你将作为玩家参与游戏，按规则将箱子 'B' 移动到目标位置 'T' ：

# 玩家用字符 'S' 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。
# 地板用字符 '.' 表示，意味着可以自由行走。
# 墙用字符 '#' 表示，意味着障碍物，不能通行。
# 箱子仅有一个，用字符 'B' 表示。相应地，网格上有一个目标位置 'T'。
# 玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。
# 玩家无法越过箱子。
# 返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 - 1。


# 示例 1：
# 输入：grid = [["#", "#", "#", "#", "#", "#"],
#            ["#", "T", "#", "#", "#", "#"],
#            ["#", ".", ".", "B", ".", "#"],
#            ["#", ".", "#", "#", ".", "#"],
#            ["#", ".", ".", ".", "S", "#"],
#            ["#", "#", "#", "#", "#", "#"]]
# 输出：3
# 解释：我们只需要返回推箱子的次数。

# 示例 2：
# 输入：grid = [["#", "#", "#", "#", "#", "#"],
#            ["#", "T", "#", "#", "#", "#"],
#            ["#", ".", ".", "B", ".", "#"],
#            ["#", "#", "#", "#", ".", "#"],
#            ["#", ".", ".", ".", "S", "#"],
#            ["#", "#", "#", "#", "#", "#"]]
# 输出：- 1

# 示例 3：
# 输入：grid = [["#", "#", "#", "#", "#", "#"],
#            ["#", "T", ".", ".", "#", "#"],
#            ["#", ".", "#", "B", ".", "#"],
#            ["#", ".", ".", ".", ".", "#"],
#            ["#", ".", ".", ".", "S", "#"],
#            ["#", "#", "#", "#", "#", "#"]]
# 输出：5
# 解释：向下、向左、向左、向上再向上。


# 提示：
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 20
# grid 仅包含字符 '.', '#',  'S', 'T', 以及 'B'。
# grid 中 'S', 'B' 和 'T' 各只能出现一个。

# Hard
# 复习

from collections import deque
from typing import List
# @lc code=start


class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        M, N = len(grid), len(grid[0])
        # 箱子不能推到一个相邻两面都是墙（边界跟墙一样）的位置（死地）
        # 求最短路径应该用广度优先搜索，不能用深度
        # 要考虑玩家的位置，1、他的位置和箱子、目标都要连通；2、有时候为了通过，必须多推几步箱子，比如测试用例1（不能是箱子和目标直接的最短路径）
        sx = sy = bx = by = -1
        for y in range(M):
            for x in range(N):
                if grid[y][x] == 'S':
                    sx, sy = x, y
                if grid[y][x] == 'B':
                    bx, by = x, y

        def canReach(x: int, y: int) -> bool:
            '''
            判断该位置是否可达
            '''
            return 0 <= x < N and 0 <= y < M and grid[y][x] != '#'

        # 二维数组，坐标分别为人的位置、盒子的位置，初始化为无穷大，值记录的是推箱子的次数
        dp = [[float('inf')] * (M * N) for _ in range(M * N)]
        dp[sy * N + sx][by * N + bx] = 0  # 初始状态的推动次数为 0
        q = deque([(sy * N + sx, by * N + bx)])  # 队列中每个元素为 人的位置和盒子的位置
        q1 = deque()
        while q:
            while q:
                s1, b1 = q.popleft()
                sy1, sx1 = s1 // N, s1 % N
                by1, bx1 = b1 // N, b1 % N
                if grid[by1][bx1] == 'T':  # 抵达目的地
                    return dp[s1][b1]
                for dx, dy in DIR:
                    nsx, nsy = sx1 + dx, sy1 + dy
                    ns = nsy * N + nsx
                    if not canReach(nsx, nsy):
                        continue
                    if ns == b1:  # 人挪到箱子的位置了
                        nbx, nby = bx1 + dx, by1 + dy
                        nb = nby * N + nbx
                        # 不可达或位置已处理过
                        if not canReach(nbx, nby) or dp[ns][nb] <= dp[s1][b1] + 1:
                            continue
                        dp[ns][nb] = dp[s1][b1] + 1
                        q1.append((ns, nb))  # q1 比 q 都多一步
                    else:
                        if dp[ns][b1] <= dp[s1][b1]:  # 位置已处理过
                            continue
                        dp[ns][b1] = dp[s1][b1]
                        q.append((ns, b1))  # 步数一样的，加q里
            q, q1 = q1, q

        return -1


        # @lc code=end
if __name__ == "__main__":
    solution = Solution()
    print(solution.minPushBox([["#", ".", ".", "#", "#", "#", "#", "#"],
                               ["#", ".", ".", "T", "#", ".", ".", "#"],
                               ["#", ".", ".", ".", "#", "B", ".", "#"],
                               ["#", ".", ".", ".", ".", ".", ".", "#"],
                               ["#", ".", ".", ".", "#", ".", "S", "#"],
                               ["#", ".", ".", "#", "#", "#", "#", "#"]]))  # 7
    print(solution.minPushBox([["#", "#", "#", "#", "#", "#", "#"],
                               ["#", "S", "#", ".", "B", "T", "#"],
                               ["#", "#", "#", "#", "#", "#", "#"]]))  # -1
    print(solution.minPushBox([["#", "#", "#", "#", "#", "#"],
                               ["#", "T", "#", "#", "#", "#"],
                               ["#", ".", ".", "B", ".", "#"],
                               ["#", ".", "#", "#", ".", "#"],
                               ["#", ".", ".", ".", "S", "#"],
                               ["#", "#", "#", "#", "#", "#"]]))  # 3
    print(solution.minPushBox([["#", "#", "#", "#", "#", "#"],
                               ["#", "T", "#", "#", "#", "#"],
                               ["#", ".", ".", "B", ".", "#"],
                               ["#", "#", "#", "#", ".", "#"],
                               ["#", ".", ".", ".", "S", "#"],
                               ["#", "#", "#", "#", "#", "#"]]))  # -1
    print(solution.minPushBox([["#", "#", "#", "#", "#", "#"],
                               ["#", "T", ".", ".", "#", "#"],
                               ["#", ".", "#", "B", ".", "#"],
                               ["#", ".", ".", ".", ".", "#"],
                               ["#", ".", ".", ".", "S", "#"],
                               ["#", "#", "#", "#", "#", "#"]]))  # 5
