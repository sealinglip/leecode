#
# @lc app=leetcode.cn id=1706 lang=python3
#
# [1706] 球会落何处
#
# 用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。

# 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。

# 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。
# 将球导向左侧的挡板跨过右上角和左下角，在网格中用 - 1 表示。
# 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。

# 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 - 1 。


# 示例 1：
# 输入：grid = [[1, 1, 1, -1, -1], [1, 1, 1, -1, -1], [-1, -1, -1, 1, 1], [1, 1, 1, 1, -1], [-1, -1, -1, -1, -1]]
# 输出：[1, -1, -1, -1, -1]
# 解释：示例如图：
# b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
# b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
# b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
# b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
# b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。

# 示例 2：
# 输入：grid = [[-1]]
# 输出：[-1]
# 解释：球被卡在箱子左侧边上。

# 示例 3：
# 输入：grid = [[1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, -1]]
# 输出：[0, 1, 2, 3, 4, -1]


# 提示：
# m == grid.length
# n == grid[i].length
# 1 <= m, n <= 100
# grid[i][j] 为 1 或 - 1

from typing import List, Tuple
# @lc code=start


class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        # 以1,2,3,4代表上左右下

        def passThrough(pos: Tuple[int]) -> Tuple[int]:
            '''
            给定位置和进入方向，得到出的位置
            dir只能为1，2，3
            '''
            if pos[2] == 1:
                # 从上进
                if grid[pos[0]][pos[1]] == 1:
                    if pos[1] == n - 1:
                        return None  # 路不通
                    else:
                        return (pos[0], pos[1] + 1, 2)
                else:
                    if pos[1] == 0:
                        return None  # 路不通
                    else:
                        return (pos[0], pos[1] - 1, 3)

            elif pos[2] == 2:
                # 从左进
                if grid[pos[0]][pos[1]] == 1:
                    return (pos[0] + 1, pos[1], 1)
                else:
                    return None  # 路不通
            elif pos[2] == 3:
                # 从右进
                if grid[pos[0]][pos[1]] == 1:
                    return None
                else:
                    return (pos[0] + 1, pos[1], 1)

        res = []
        for col in range(n):
            pos = (0, col, 1)
            while (pos := passThrough(pos)):
                if pos[0] == m:
                    res.append(pos[1])
                    break
            else:
                res.append(-1)

        return res

        # @lc code=end
if __name__ == "__main__":
    solution = Solution()
    print(solution.findBall([[-1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1,
                              1, -1, 1, -1, 1, 1, 1, -1, -1, -1, -1]]))  # [-1,-1,-1,2,3,4,5,6,-1,-1,9,10,11,14,-1,-1,15,16,19,20,-1,-1,21,24,-1,-1,25,-1,-1,28,29,30,31,32,33,34,35,-1,-1,-1,-1,40,41,42,43,44,45,-1,-1,48,-1,-1,-1,-1,53,56,-1,-1,-1,-1,59,60,61,64,65,66,67,68,-1,-1,71,72,-1,-1,75,76,-1,-1,77,78,-1,-1,-1,-1,83,86,-1,-1,87,-1,-1,-1,-1,94,95,-1,-1,96,97,98]
    print(solution.findBall([[1, 1, 1, -1, -1], [1, 1, 1, -1, -1],
                             [-1, -1, -1, 1, 1], [1, 1, 1, 1, -1], [-1, -1, -1, -1, -1]]))  # [1, -1, -1, -1, -1]
    print(solution.findBall([[-1]]))  # [-1]
    print(solution.findBall([[1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -
                                                  1, -1], [1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, -1]]))  # [0, 1, 2, 3, 4, -1]
