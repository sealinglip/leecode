#
# @lc app=leetcode.cn id=787 lang=python3
#
# [787] K 站中转内最便宜的航班
#
# 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。

# 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 - 1。


# 示例 1：
# 输入:
# n = 3, edges = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]
# src = 0, dst = 2, k = 1
# 输出: 200
# 解释:
# 城市航班图如下
# 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。

# 示例 2：
# 输入:
# n = 3, edges = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]
# src = 0, dst = 2, k = 0
# 输出: 500
# 解释:
# 城市航班图如下
# 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。


# 提示：
# 1 <= n <= 100
# 0 <= flights.length <= (n * (n - 1) / 2)
# flights[i].length == 3
# 0 <= fromi, toi < n
# fromi != toi
# 1 <= pricei <= 104
# 航班没有重复，且不存在自环
# 0 <= src, dst, k < n
# src != dst

# 高阶版 1928

from typing import List
# @lc code=start
from collections import defaultdict, deque
from heapq import heappush, heappop


class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        edges = defaultdict(list)
        for s, d, p in flights:
            edges[s].append((d, p))  # 保存目的地和价格

        # 下面的实现会超时
        # minPrice = -1
        # visited = set()

        # def find(s: int, d: int, step: int, p: int):
        #     if step < 0:
        #         return
        #     nonlocal minPrice
        #     for d2, p2 in edges[s]:
        #         if d2 == d:
        #             if minPrice == -1 or minPrice > (p + p2):
        #                 minPrice = p + p2
        #         elif step > 0 and d2 not in visited:
        #             visited.add(d2)
        #             find(d2, d, step - 1, p + p2)
        #             visited.remove(d2)

        # # BFS
        # find(src, dst, k, 0)
        # return minPrice

        # 先判断有没有通路
        visited = set()
        q = deque([(src, -1)])
        while q:
            l, s = q.popleft()
            visited.add(l)

            if s > k:
                break
            elif s == k:
                continue
            s += 1
            for d, _ in edges[l]:
                if d not in visited:
                    q.append((d, s))

        if dst not in visited:
            return -1

        # 改成优先队列优化时间
        pq = [[0, 0, src]]  # 价格/中转数/地点
        while pq:
            p, s, l = heappop(pq)
            if l == dst:
                return p
            if s <= k:
                s += 1
                for d, p2 in edges[l]:
                    heappush(pq, [p + p2, s, d])

        return -1
# @lc code=end


if __name__ == "__main__":
    solution = Solution()
    # 第一种方法下面这个用例会超时
    print(solution.findCheapestPrice(17, [[0, 12, 28], [5, 6, 39], [8, 6, 59], [13, 15, 7], [13, 12, 38], [10, 12, 35], [15, 3, 23], [7, 11, 26], [9, 4, 65], [10, 2, 38], [4, 7, 7], [14, 15, 31], [2, 12, 44], [8, 10, 34], [13, 6, 29], [5, 14, 89], [11, 16, 13], [7, 3, 46], [10, 15, 19], [12, 4, 58], [13, 16, 11], [16, 4, 76], [2, 0, 12], [15, 0, 22], [16, 12, 13], [7, 1, 29], [7, 14, 100], [16, 1, 14], [9, 6, 74], [11, 1, 73], [2, 11, 60], [10, 11, 85], [2, 5, 49], [3, 4, 17], [4, 9, 77], [16, 3, 47], [15, 6, 78], [14, 1, 90], [10, 5, 95], [1, 11, 30], [11, 0, 37], [10, 4, 86], [0, 8, 57], [6, 14, 68], [16, 8, 3], [13, 0, 65], [2, 13, 6], [5, 13, 5], [8, 11, 31], [6, 10, 20], [6, 2, 33], [9, 1, 3], [14, 9, 58], [12, 3, 19], [11, 2, 74], [12, 14, 48], [
          16, 11, 100], [3, 12, 38], [12, 13, 77], [10, 9, 99], [15, 13, 98], [15, 12, 71], [1, 4, 28], [7, 0, 83], [3, 5, 100], [8, 9, 14], [15, 11, 57], [3, 6, 65], [1, 3, 45], [14, 7, 74], [2, 10, 39], [4, 8, 73], [13, 5, 77], [10, 0, 43], [12, 9, 92], [8, 2, 26], [1, 7, 7], [9, 12, 10], [13, 11, 64], [8, 13, 80], [6, 12, 74], [9, 7, 35], [0, 15, 48], [3, 7, 87], [16, 9, 42], [5, 16, 64], [4, 5, 65], [15, 14, 70], [12, 0, 13], [16, 14, 52], [3, 10, 80], [14, 11, 85], [15, 2, 77], [4, 11, 19], [2, 7, 49], [10, 7, 78], [14, 6, 84], [13, 7, 50], [11, 6, 75], [5, 10, 46], [13, 8, 43], [9, 10, 49], [7, 12, 64], [0, 10, 76], [5, 9, 77], [8, 3, 28], [11, 9, 28], [12, 16, 87], [12, 6, 24], [9, 15, 94], [5, 7, 77], [4, 10, 18], [7, 2, 11], [9, 5, 41]], 13, 4, 13))
    # # 优先队列下面这个用例会超时
    print(solution.findCheapestPrice(13, [[11, 12, 74], [1, 8, 91], [4, 6, 13], [7, 6, 39], [5, 12, 8], [0, 12, 54], [8, 4, 32], [0, 11, 4], [4, 0, 91], [11, 7, 64], [6, 3, 88], [8, 5, 80], [11, 10, 91], [10, 0, 60], [8, 7, 92], [12, 6, 78], [6, 2, 8], [4, 3, 54], [3, 11, 76], [3, 12, 23], [11, 6, 79], [6, 12, 36], [2, 11, 100], [2, 5, 49], [7, 0, 17], [5, 8, 95], [3, 9, 98], [
          8, 10, 61], [2, 12, 38], [5, 7, 58], [9, 4, 37], [8, 6, 79], [9, 0, 1], [2, 3, 12], [7, 10, 7], [12, 10, 52], [7, 2, 68], [12, 2, 100], [6, 9, 53], [7, 4, 90], [0, 5, 43], [11, 2, 52], [11, 8, 50], [12, 4, 38], [7, 9, 94], [2, 7, 38], [3, 7, 88], [9, 12, 20], [12, 0, 26], [10, 5, 38], [12, 8, 50], [0, 2, 77], [11, 0, 13], [9, 10, 76], [2, 6, 67], [5, 6, 34], [9, 7, 62], [5, 3, 67]], 10, 1, 10))
    print(solution.findCheapestPrice(
        3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1))
    print(solution.findCheapestPrice(
        3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0))
